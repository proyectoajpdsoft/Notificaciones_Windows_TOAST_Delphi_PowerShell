unit UnidadNotificacion;

interface

uses
  Winapi.Windows, Winapi.ShellAPI, Winapi.ShlObj, Winapi.ActiveX, Winapi.PropSys,
  System.SysUtils, System.Classes, System.Notification, System.JSON,
  System.IOUtils, System.NetEncoding, System.Win.ComObj, System.DateUtils,
  System.Win.Registry, System.StrUtils,
  Vcl.Forms, Vcl.ExtCtrls, Vcl.Controls;

const
  IID_IPersistFile: TGUID = '{0000010b-0000-0000-C000-000000000046}';
  PKEY_AppUserModel_ID: TPropertyKey = (
    fmtid: '{9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}';
    pid: 5
  );

type
  // Almacena la configuración global cargada desde config.json.
  TAppConfig = record
    AppID: string;
    AppDisplayName: string;
    MinutosLimiteDuplicados: Integer;
    IconoNotificacion: string;
    RutaXmlTemplate: string;
  end;

  TformNotificacionesWindows = class(TForm)
    CentroNotificaciones: TNotificationCenter;
    Temporizador: TTimer;
    procedure FormCreate(Sender: TObject);
    procedure TemporizadorTimer(Sender: TObject);
  private
    FConfig: TAppConfig;
    FRutaArchivoLog: string;
    FRutaArchivoMensaje: string;
    FRutaArchivoHistorial: string;

    procedure CargarConfiguracion;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure ConfigurarRegistroNotificaciones;
    procedure EscribirLog(const Mensaje: string; EsError: Boolean = False);
    procedure MostrarNotificacionDesdeJSON;
    procedure MostrarNotificacionPowerShell(const Titulo, Cuerpo: string; DatosJSON: TJSONObject);
    procedure EjecutarComandoPowershell(const Script: string);
    function HaSidoMostradaRecientemente(const ATitulo, ACuerpo: string): Boolean;
    procedure RegistrarNotificacionEnHistorial(const ATitulo, ACuerpo: string);
    procedure CrearAccesoDirectoConAppID;
  end;

var
  formNotificacionesWindows: TformNotificacionesWindows;

implementation

{$R *.dfm}

procedure TformNotificacionesWindows.CreateParams(var Params: TCreateParams);
begin
  // Se sobreescribe este método para eliminar el estilo WS_VISIBLE antes de que
  // la ventana se cree, asegurando que el formulario nunca sea visible.
  inherited CreateParams(Params);
  Params.Style := Params.Style and not WS_VISIBLE;
end;

procedure TformNotificacionesWindows.FormCreate(Sender: TObject);
begin
  try
    FRutaArchivoLog := ChangeFileExt(Application.ExeName, '.log');
    FRutaArchivoHistorial := ChangeFileExt(Application.ExeName, '.historial.json');

    CargarConfiguracion;
    ConfigurarRegistroNotificaciones;

    if ParamCount = 0 then
    begin
      EscribirLog('No se especificó un archivo JSON de mensaje como parámetro.', True);
      Application.Terminate;
      Exit;
    end;

    FRutaArchivoMensaje := ParamStr(1);
    if not FileExists(FRutaArchivoMensaje) then
    begin
      EscribirLog('El archivo de mensaje "' + FRutaArchivoMensaje + '" no existe.', True);
      Application.Terminate;
      Exit;
    end;

    CrearAccesoDirectoConAppID;

    // Se usa un temporizador corto para desacoplar la lógica principal del evento
    // FormCreate, permitiendo que el formulario se cargue completamente en memoria
    // antes de ejecutar la acción principal y cerrar la aplicación.
    Temporizador.Interval := 100;
    Temporizador.Enabled := True;
  except
    on E: Exception do
    begin
      EscribirLog('Error durante la inicialización: ' + E.Message, True);
      Vcl.Forms.Application.Terminate;
    end;
  end;
end;

procedure TformNotificacionesWindows.CargarConfiguracion;
var
  RutaConfig: string;
  DatosJSON: TJSONObject;
  TemplateContent: TStringList;
begin
  RutaConfig := TPath.Combine(ExtractFilePath(Application.ExeName), 'config.json');

  if not FileExists(RutaConfig) then
  begin
    EscribirLog('No se encontró el fichero de configuración. Se crea "config.json" por defecto.');
    DatosJSON := TJSONObject.Create;
    try
      DatosJSON.AddPair('app_id', 'ProyectoA.Notificaciones');
      DatosJSON.AddPair('app_display_name', 'ProyectoA Notificaciones');
      DatosJSON.AddPair('minutos_limite_duplicados', TJSONNumber.Create(120));
      DatosJSON.AddPair('icono_notificacion', '');
      DatosJSON.AddPair('ruta_xml_template', 'notificacion_template.xml');
      TFile.WriteAllText(RutaConfig, DatosJSON.ToJSON);
    finally
      DatosJSON.Free;
    end;
  end;

  DatosJSON := TJSONObject.ParseJSONValue(TFile.ReadAllText(RutaConfig)) as TJSONObject;
  if Assigned(DatosJSON) then
  begin
    try
      FConfig.AppID := DatosJSON.GetValue<string>('app_id', 'Default.AppID');
      FConfig.AppDisplayName := DatosJSON.GetValue<string>('app_display_name', 'Default Display Name');
      FConfig.MinutosLimiteDuplicados := DatosJSON.GetValue<Integer>('minutos_limite_duplicados', 120);
      FConfig.IconoNotificacion := DatosJSON.GetValue<string>('icono_notificacion', '');
      FConfig.RutaXmlTemplate := TPath.Combine(ExtractFilePath(Application.ExeName), DatosJSON.GetValue<string>('ruta_xml_template', 'notificacion_template.xml'));
    finally
      DatosJSON.Free;
    end;
  end;

  if not FileExists(FConfig.RutaXmlTemplate) then
  begin
    EscribirLog('No se encontró el fichero de plantilla XML. Se crea por defecto.');
    TemplateContent := TStringList.Create;
    try
      TemplateContent.Add('<toast##ToastAttributes##>');
      TemplateContent.Add('    <visual>');
      TemplateContent.Add('        <binding template="ToastGeneric">');
      TemplateContent.Add('##LogoImageXML##');
      TemplateContent.Add('##HeroImageXML##');
      TemplateContent.Add('            <text>$Titulo</text>');
      TemplateContent.Add('            <text>$Cuerpo</text>');
      TemplateContent.Add('##InlineImageXML##');
      TemplateContent.Add('##PieXML##');
      TemplateContent.Add('        </binding>');
      TemplateContent.Add('    </visual>');
      TemplateContent.Add('##ActionsXML##');
      TemplateContent.Add('</toast>');
      TemplateContent.SaveToFile(FConfig.RutaXmlTemplate);
    finally
      TemplateContent.Free;
    end;
  end;
end;

procedure TformNotificacionesWindows.ConfigurarRegistroNotificaciones;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Notifications\Settings\' + FConfig.AppID, True) then
    begin
      Reg.WriteString('DisplayName', FConfig.AppDisplayName);
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;

procedure TformNotificacionesWindows.TemporizadorTimer(Sender: TObject);
begin
  Temporizador.Enabled := False;
  try
    MostrarNotificacionDesdeJSON;
  finally
    Application.Terminate;
  end;
end;

procedure TformNotificacionesWindows.CrearAccesoDirectoConAppID;
var
  RutaAccesoDirecto, RutaMenuInicio: string;
  ShellLink: IShellLinkW;
  PropStore: IPropertyStore;
  PersistFile: IPersistFile;
  PropVariant: TPropVariant;
  PathBuffer: array[0..MAX_PATH-1] of Char;
begin
  if Succeeded(SHGetFolderPath(0, CSIDL_STARTMENU, 0, SHGFP_TYPE_CURRENT, @PathBuffer[0])) then
    RutaMenuInicio := PathBuffer
  else
    Exit;
  RutaAccesoDirecto := TPath.Combine(RutaMenuInicio, FConfig.AppDisplayName + '.lnk');
  if FileExists(RutaAccesoDirecto) then
    Exit;

  CoInitialize(nil);
  try
    if Succeeded(CoCreateInstance(CLSID_ShellLink, nil, CLSCTX_INPROC_SERVER, IID_IShellLinkW, ShellLink)) then
    begin
      ShellLink.SetPath(PChar(Application.ExeName));
      if (FConfig.IconoNotificacion <> '') and FileExists(FConfig.IconoNotificacion) then
        ShellLink.SetIconLocation(PChar(FConfig.IconoNotificacion), 0);

      if Succeeded(ShellLink.QueryInterface(IID_IPropertyStore, PropStore)) then
      begin
        OleCheck(InitPropVariantFromString(PChar(FConfig.AppID), PropVariant));
        OleCheck(PropStore.SetValue(PKEY_AppUserModel_ID, PropVariant));
        OleCheck(PropStore.Commit);
        PropVariantClear(PropVariant);
      end;
      if Succeeded(ShellLink.QueryInterface(IID_IPersistFile, PersistFile)) then
        PersistFile.Save(PWideChar(RutaAccesoDirecto), True);
    end;
  finally
    CoUninitialize;
  end;
end;

procedure TformNotificacionesWindows.EscribirLog(const Mensaje: string; EsError: Boolean = False);
var
  ArchivoLog: TextFile;
  Prefijo: string;
begin
  try
    if EsError then Prefijo := '[ERROR] ' else Prefijo := '[INFO] ';
    AssignFile(ArchivoLog, FRutaArchivoLog);
    try
      if FileExists(FRutaArchivoLog) then Append(ArchivoLog) else Rewrite(ArchivoLog);
      Writeln(ArchivoLog, Format('[%s] %s%s', [FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), Prefijo, Mensaje]));
    finally
      CloseFile(ArchivoLog);
    end;
  except
  end;
end;

procedure TformNotificacionesWindows.MostrarNotificacionDesdeJSON;
var
  ContenidoJSON: TStringList;
  DatosJSON: TJSONObject;
  Notificacion: TNotification;
  Titulo, Cuerpo, TipoNotificacion: string;
begin
  ContenidoJSON := TStringList.Create;
  try
    ContenidoJSON.LoadFromFile(FRutaArchivoMensaje, TEncoding.UTF8);
    DatosJSON := TJSONObject.ParseJSONValue(ContenidoJSON.Text) as TJSONObject;
    if not Assigned(DatosJSON) then
    begin
      EscribirLog('El contenido del fichero de mensaje no es un JSON válido.', True);
      Exit;
    end;
    try
      Titulo := DatosJSON.GetValue<string>('titulo');
      Cuerpo := DatosJSON.GetValue<string>('cuerpo');
      if HaSidoMostradaRecientemente(Titulo, Cuerpo) then
      begin
        EscribirLog(Format('Notificación duplicada ("%s") dentro del límite de tiempo.', [Titulo]));
        Exit;
      end;
      TipoNotificacion := DatosJSON.GetValue<string>('tipo_notificacion', 'normal');
      if SameText(TipoNotificacion, 'powershell') then
        MostrarNotificacionPowerShell(Titulo, Cuerpo, DatosJSON)
      else
      begin
        Notificacion := CentroNotificaciones.CreateNotification;
        try
          Notificacion.Name := FConfig.AppID;
          Notificacion.Title := Titulo;
          Notificacion.AlertBody := StringReplace(Cuerpo, '\n', #13#10, [rfReplaceAll]);
          CentroNotificaciones.PresentNotification(Notificacion);
        finally
          Notificacion.Free;
        end;
      end;
      RegistrarNotificacionEnHistorial(Titulo, Cuerpo);
      EscribirLog('Notificación enviada (Tipo: ' + TipoNotificacion + ').');
    finally
      DatosJSON.Free;
    end;
  finally
    ContenidoJSON.Free;
  end;
end;

procedure TformNotificacionesWindows.MostrarNotificacionPowerShell(const Titulo, Cuerpo: string; DatosJSON: TJSONObject);
var
  ScriptPS, ToastTemplateXML, LaunchAttribute, DurationAttribute, AccionPrincipalXML,
  BotonCerrarXML, PieXML, HeroImageXML, InlineImageXML, LogoImageXML, CuerpoPS,
  RutaImagenLogo, RutaImagenArriba, RutaImagenInline, PieNotificacion, AccionPrincipal,
  ToastAttributes, ActionsXML: string;
begin
  // --- PREPARACIÓN DE VARIABLES DE POWERSHELL ---
  RutaImagenLogo := DatosJSON.GetValue<string>('imagen_logo', '');
  if (RutaImagenLogo <> '') and FileExists(RutaImagenLogo) then RutaImagenLogo := TPath.GetFullPath(RutaImagenLogo) else RutaImagenLogo := '';
  RutaImagenArriba := DatosJSON.GetValue<string>('imagen_arriba', '');
  if (RutaImagenArriba <> '') and FileExists(RutaImagenArriba) then RutaImagenArriba := TPath.GetFullPath(RutaImagenArriba) else RutaImagenArriba := '';
  RutaImagenInline := DatosJSON.GetValue<string>('imagen_inline', '');
  if (RutaImagenInline <> '') and FileExists(RutaImagenInline) then RutaImagenInline := TPath.GetFullPath(RutaImagenInline) else RutaImagenInline := '';
  PieNotificacion := DatosJSON.GetValue<string>('pie_notificacion', '');
  AccionPrincipal := DatosJSON.GetValue<string>('accion_principal', '');

  // --- PREPARACIÓN DE FRAGMENTOS XML (O CADENAS VACÍAS SI NO APLICAN) ---
  LaunchAttribute := '';
  if AccionPrincipal <> '' then LaunchAttribute := ' launch="$AccionPrincipal" activationType="protocol"';
  if SameText(DatosJSON.GetValue<string>('duracion', 'corta'), 'larga') then DurationAttribute := ' duration="long"' else DurationAttribute := '';
  LogoImageXML := '';
  if RutaImagenLogo <> '' then LogoImageXML := '##LogoImageXML##';
  HeroImageXML := '';
  if RutaImagenArriba <> '' then HeroImageXML := '##HeroImageXML##';
  InlineImageXML := '';
  if RutaImagenInline <> '' then InlineImageXML := '##InlineImageXML##';
  PieXML := '';
  if PieNotificacion <> '' then PieXML := '##PieXML##';
  AccionPrincipalXML := '';
  if AccionPrincipal <> '' then AccionPrincipalXML := '<action content="Abrir" arguments="$AccionPrincipal" activationType="protocol"/>';
  BotonCerrarXML := '';
  if DatosJSON.GetValue<Boolean>('mostrar_boton_cerrar', False) then BotonCerrarXML := '<action content="Cerrar" arguments="dismiss" activationType="system"/>';

  // --- LECTURA Y REEMPLAZO EN LA PLANTILLA ---
  ToastTemplateXML := TFile.ReadAllText(FConfig.RutaXmlTemplate);
  ToastAttributes := DurationAttribute + LaunchAttribute;

  if (AccionPrincipalXML <> '') or (BotonCerrarXML <> '') then
    ActionsXML := #13#10 + '    <actions>' + #13#10 + '        ' + AccionPrincipalXML + #13#10 + '        ' + BotonCerrarXML + #13#10 + '    </actions>'
  else
    ActionsXML := '';

  ToastTemplateXML := StringReplace(ToastTemplateXML, '##ToastAttributes##', ToastAttributes, [rfReplaceAll]);
  ToastTemplateXML := StringReplace(ToastTemplateXML, '##LogoImageXML##', IfThen(LogoImageXML<>'', '<image placement="appLogoOverride" src="$ImagenLogo"/>', ''), [rfReplaceAll]);
  ToastTemplateXML := StringReplace(ToastTemplateXML, '##HeroImageXML##', IfThen(HeroImageXML<>'', '<image placement="hero" src="$ImagenArriba"/>', ''), [rfReplaceAll]);
  ToastTemplateXML := StringReplace(ToastTemplateXML, '##InlineImageXML##', IfThen(InlineImageXML<>'', '<image src="$ImagenInline"/>', ''), [rfReplaceAll]);
  ToastTemplateXML := StringReplace(ToastTemplateXML, '##PieXML##', IfThen(PieXML<>'', '<text placement="attribution">$PieNotificacion</text>', ''), [rfReplaceAll]);
  ToastTemplateXML := StringReplace(ToastTemplateXML, '##ActionsXML##', ActionsXML, [rfReplaceAll]);

  // --- CONSTRUCCIÓN DEL SCRIPT DE POWERSHELL ---
  CuerpoPS := StringReplace(StringReplace(Cuerpo, '\n', '`n', [rfReplaceAll]), '"', '`"', [rfReplaceAll]);
  ScriptPS :=
    '$Titulo = ''' + Titulo.Replace('''', '''''') + ''';' + #13#10 +
    '$Cuerpo = "' + CuerpoPS + '";' + #13#10 +
    '$ImagenLogo = ''' + RutaImagenLogo.Replace('''', '''''') + ''';' + #13#10 +
    '$ImagenArriba = ''' + RutaImagenArriba.Replace('''', '''''') + ''';' + #13#10 +
    '$ImagenInline = ''' + RutaImagenInline.Replace('''', '''''') + ''';' + #13#10 +
    '$PieNotificacion = ''' + PieNotificacion.Replace('''', '''''') + ''';' + #13#10 +
    '$AccionPrincipal = ''' + AccionPrincipal.Replace('''', '''''') + ''';' + #13#10 +
    '$AppId = ''' + FConfig.AppID + ''';' + #13#10 +
    '$ToastTemplate = @"' + #13#10 + ToastTemplateXML + #13#10 + '"@' + #13#10 +
    '[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null;' + #13#10 +
    '[Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime] | Out-Null;' + #13#10 +
    '$ToastXml = New-Object Windows.Data.Xml.Dom.XmlDocument;' + #13#10 +
    '$ToastXml.LoadXml($ToastTemplate);' + #13#10 +
    '$Toast = [Windows.UI.Notifications.ToastNotification]::new($ToastXml);' + #13#10 +
    '[Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier($AppId).Show($Toast);';

  EjecutarComandoPowershell(ScriptPS);
end;

procedure TformNotificacionesWindows.EjecutarComandoPowershell(const Script: string);
var
  ComandoBase64, ComandoCompleto: string;
  SI: TStartupInfo;
  PI: TProcessInformation;
begin
  ComandoBase64 := TNetEncoding.Base64.EncodeBytesToString(TEncoding.Unicode.GetBytes(Script));
  ComandoCompleto := 'powershell.exe -NoProfile -ExecutionPolicy Bypass -EncodedCommand ' + ComandoBase64;
  EscribirLog('Ejecutando PowerShell para mostrar notificación...');
  ZeroMemory(@SI, SizeOf(SI));
  SI.cb := SizeOf(SI);
  SI.dwFlags := STARTF_USESHOWWINDOW;
  SI.wShowWindow := SW_HIDE;
  ZeroMemory(@PI, SizeOf(PI));
  if not CreateProcess(nil, PChar(ComandoCompleto), nil, nil, False, CREATE_NO_WINDOW, nil, nil, SI, PI) then
  begin
    EscribirLog('Error al ejecutar PowerShell: ' + SysErrorMessage(GetLastError), True);
    Exit;
  end;
  try
    WaitForSingleObject(PI.hProcess, 5000);
  finally
    CloseHandle(PI.hProcess);
    CloseHandle(PI.hThread);
  end;
end;

function TformNotificacionesWindows.HaSidoMostradaRecientemente(const ATitulo, ACuerpo: string): Boolean;
var
  Historial: TJSONArray;
  Item: TJSONValue;
  FechaNotificacion: TDateTime;
  FS: TFormatSettings;
begin
  Result := False;
  if not FileExists(FRutaArchivoHistorial) then Exit;
  FS := TFormatSettings.Create;
  FS.ShortDateFormat := 'yyyy-mm-dd';
  FS.DateSeparator := '-';
  FS.TimeSeparator := ':';
  Historial := nil;
  try
    Historial := TJSONObject.ParseJSONValue(TFile.ReadAllText(FRutaArchivoHistorial)) as TJSONArray;
    if not Assigned(Historial) then Exit;
    for Item in Historial do
    begin
      if (Item is TJSONObject) and
         SameText((Item as TJSONObject).GetValue<string>('titulo', ''), ATitulo) and
         SameText((Item as TJSONObject).GetValue<string>('cuerpo', ''), ACuerpo) then
      begin
        if TryStrToDateTime((Item as TJSONObject).GetValue<string>('fecha', ''), FechaNotificacion, FS) then
        begin
          if MinutesBetween(Now, FechaNotificacion) <= FConfig.MinutosLimiteDuplicados then
          begin
            Result := True;
            Exit;
          end;
        end;
      end;
    end;
  finally
    if Assigned(Historial) then
      Historial.Free;
  end;
end;

procedure TformNotificacionesWindows.RegistrarNotificacionEnHistorial(const ATitulo, ACuerpo: string);
var
  Historial: TJSONArray;
  NuevaNotificacion: TJSONObject;
begin
  Historial := nil;
  try
    if FileExists(FRutaArchivoHistorial) then
      Historial := TJSONObject.ParseJSONValue(TFile.ReadAllText(FRutaArchivoHistorial)) as TJSONArray;
    if not Assigned(Historial) then
      Historial := TJSONArray.Create;
    NuevaNotificacion := TJSONObject.Create;
    NuevaNotificacion.AddPair('titulo', ATitulo);
    NuevaNotificacion.AddPair('cuerpo', ACuerpo);
    NuevaNotificacion.AddPair('fecha', FormatDateTime('yyyy-mm-dd hh:nn:ss', Now));
    Historial.AddElement(NuevaNotificacion);
    TFile.WriteAllText(FRutaArchivoHistorial, Historial.ToString);
  finally
    if Assigned(Historial) then
      Historial.Free;
  end;
end;

end.
