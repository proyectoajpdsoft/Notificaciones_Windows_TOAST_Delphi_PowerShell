unit UnidadNotificacion;

interface

uses
  Winapi.Windows, Winapi.ShellAPI, Winapi.ShlObj, Winapi.ActiveX, Winapi.PropSys,
  System.SysUtils, System.Classes, System.Notification, System.JSON,
  System.IOUtils, System.NetEncoding, System.Win.ComObj, System.DateUtils,
  System.Win.Registry, System.StrUtils,
  Vcl.Forms, Vcl.ExtCtrls, Vcl.Controls;

const
  APP_ID = 'ProyectoA Notificaciones Windows';
  APP_DISPLAY_NAME = 'ProyectoA Notificaciones';
  MINUTOS_LIMITE_DUPLICADOS = 120;

  IID_IPersistFile: TGUID = '{0000010b-0000-0000-C000-000000000046}';
  PKEY_AppUserModel_ID: TPropertyKey = (
    fmtid: '{9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}';
    pid: 5
  );

type
  TformNotificacionesWindows = class(TForm)
    CentroNotificaciones: TNotificationCenter;
    Temporizador: TTimer;
    procedure FormCreate(Sender: TObject);
    procedure TemporizadorTimer(Sender: TObject);
  private
    FRutaArchivoLog: string;
    FRutaArchivoConfig: string;
    FRutaArchivoHistorial: string;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure ConfigurarRegistroNotificaciones;
    procedure EscribirLog(const Mensaje: string; EsError: Boolean = False);
    procedure MostrarNotificacionDesdeJSON;
    procedure MostrarNotificacionPowerShell(const Titulo, Cuerpo: string; DatosJSON: TJSONObject);
    procedure EjecutarComandoPowershell(const Script: string);
    function HaSidoMostradaRecientemente(const ATitulo, ACuerpo: string): Boolean;
    procedure RegistrarNotificacionEnHistorial(const ATitulo, ACuerpo: string);
    procedure CrearAccesoDirectoConAppID;
  end;

var
  formNotificacionesWindows: TformNotificacionesWindows;

implementation

{$R *.dfm}

procedure TformNotificacionesWindows.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);
  Params.Style := Params.Style and not WS_VISIBLE;
end;

procedure TformNotificacionesWindows.FormCreate(Sender: TObject);
begin
  try
    FRutaArchivoLog := ChangeFileExt(Application.ExeName, '.log');
    FRutaArchivoHistorial := ChangeFileExt(Application.ExeName, '.historial.json');
    ConfigurarRegistroNotificaciones;
    CrearAccesoDirectoConAppID;
    if ParamCount = 0 then
    begin
      EscribirLog('No se especificó un archivo JSON de configuración como parámetro.', True);
      Application.Terminate;
      Exit;
    end;
    FRutaArchivoConfig := ParamStr(1);
    if not FileExists(FRutaArchivoConfig) then
    begin
      EscribirLog('El archivo de configuración "' + FRutaArchivoConfig + '" no existe.', True);
      Application.Terminate;
      Exit;
    end;
    Temporizador.Interval := 100;
    Temporizador.Enabled := True;
  except
    on E: Exception do
    begin
      EscribirLog('Error fatal durante la inicialización: ' + E.Message, True);
      Vcl.Forms.Application.Terminate;
    end;
  end;
end;

procedure TformNotificacionesWindows.ConfigurarRegistroNotificaciones;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Notifications\Settings\' + APP_ID, True) then
    begin
      Reg.WriteString('DisplayName', APP_DISPLAY_NAME);
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;

procedure TformNotificacionesWindows.TemporizadorTimer(Sender: TObject);
begin
  Temporizador.Enabled := False;
  try
    MostrarNotificacionDesdeJSON;
  finally
    Application.Terminate;
  end;
end;

procedure TformNotificacionesWindows.CrearAccesoDirectoConAppID;
var
  RutaAccesoDirecto, RutaMenuInicio: string;
  ShellLink: IShellLinkW;
  PropStore: IPropertyStore;
  PersistFile: IPersistFile;
  PropVariant: TPropVariant;
  PathBuffer: array[0..MAX_PATH-1] of Char;
begin
  if Succeeded(SHGetFolderPath(0, CSIDL_STARTMENU, 0, SHGFP_TYPE_CURRENT, @PathBuffer[0])) then
    RutaMenuInicio := PathBuffer
  else
    Exit;
  RutaAccesoDirecto := TPath.Combine(RutaMenuInicio, APP_DISPLAY_NAME + '.lnk');
  if FileExists(RutaAccesoDirecto) then
    Exit;
  CoInitialize(nil);
  try
    if Succeeded(CoCreateInstance(CLSID_ShellLink, nil, CLSCTX_INPROC_SERVER, IID_IShellLinkW, ShellLink)) then
    begin
      ShellLink.SetPath(PChar(Application.ExeName));
      if Succeeded(ShellLink.QueryInterface(IID_IPropertyStore, PropStore)) then
      begin
        OleCheck(InitPropVariantFromString(APP_ID, PropVariant));
        OleCheck(PropStore.SetValue(PKEY_AppUserModel_ID, PropVariant));
        OleCheck(PropStore.Commit);
        PropVariantClear(PropVariant);
      end;
      if Succeeded(ShellLink.QueryInterface(IID_IPersistFile, PersistFile)) then
        PersistFile.Save(PWideChar(RutaAccesoDirecto), True);
    end;
  finally
    CoUninitialize;
  end;
end;

procedure TformNotificacionesWindows.EscribirLog(const Mensaje: string; EsError: Boolean = False);
var
  ArchivoLog: TextFile;
  Prefijo: string;
begin
  try
    if EsError then Prefijo := '[ERROR] ' else Prefijo := '[INFO] ';
    AssignFile(ArchivoLog, FRutaArchivoLog);
    try
      if FileExists(FRutaArchivoLog) then Append(ArchivoLog) else Rewrite(ArchivoLog);
      Writeln(ArchivoLog, Format('[%s] %s%s', [FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), Prefijo, Mensaje]));
    finally
      CloseFile(ArchivoLog);
    end;
  except
  end;
end;

procedure TformNotificacionesWindows.MostrarNotificacionDesdeJSON;
var
  ContenidoJSON: TStringList;
  DatosJSON: TJSONObject;
  Notificacion: TNotification;
  Titulo, Cuerpo, TipoNotificacion: string;
begin
  ContenidoJSON := TStringList.Create;
  try
    ContenidoJSON.LoadFromFile(FRutaArchivoConfig, TEncoding.UTF8);
    DatosJSON := TJSONObject.ParseJSONValue(ContenidoJSON.Text) as TJSONObject;
    if not Assigned(DatosJSON) then
    begin
      EscribirLog('El contenido del fichero de configuración no es un JSON válido.', True);
      Exit;
    end;
    try
      Titulo := DatosJSON.GetValue<string>('titulo');
      Cuerpo := DatosJSON.GetValue<string>('cuerpo');
      if HaSidoMostradaRecientemente(Titulo, Cuerpo) then
      begin
        EscribirLog(Format('Notificación duplicada ("%s") dentro del límite de tiempo.', [Titulo]));
        Exit;
      end;
      TipoNotificacion := DatosJSON.GetValue<string>('tipo_notificacion', 'normal');
      if SameText(TipoNotificacion, 'powershell') then
        MostrarNotificacionPowerShell(Titulo, Cuerpo, DatosJSON)
      else
      begin
        Notificacion := CentroNotificaciones.CreateNotification;
        try
          Notificacion.Name := APP_ID;
          Notificacion.Title := Titulo;
          Notificacion.AlertBody := StringReplace(Cuerpo, '\n', #13#10, [rfReplaceAll]);
          CentroNotificaciones.PresentNotification(Notificacion);
        finally
          Notificacion.Free;
        end;
      end;
      RegistrarNotificacionEnHistorial(Titulo, Cuerpo);
      EscribirLog('Notificación enviada (Tipo: ' + TipoNotificacion + ').');
    finally
      DatosJSON.Free;
    end;
  finally
    ContenidoJSON.Free;
  end;
end;

procedure TformNotificacionesWindows.MostrarNotificacionPowerShell(const Titulo, Cuerpo: string; DatosJSON: TJSONObject);
var
  ScriptPS, ToastTemplateXML, LaunchAttribute, DurationAttribute, AccionPrincipalXML,
  BotonCerrarXML, PieXML, HeroImageXML, InlineImageXML, BodyTextXML,
  CuerpoPowerShellArray: string;
  LineasCuerpo, LineasEscapadas: TStringList;
  I: Integer;
begin
  // --- PREPARACIÓN DE VARIABLES DEL XML ---
  LaunchAttribute := '';
  if DatosJSON.GetValue<string>('accion_principal', '') <> '' then
    LaunchAttribute := ' launch="$AccionPrincipal" activationType="protocol"';

  if SameText(DatosJSON.GetValue<string>('duracion', 'corta'), 'larga') then
    DurationAttribute := ' duration="long"'
  else
    DurationAttribute := '';

  HeroImageXML := '';
  // Se usa "appLogoOverride" para la imagen a la izquierda (por defecto o con "izquierda")
  // y "hero" para la imagen superior.
  if FileExists(DatosJSON.GetValue<string>('imagen', '')) then
  begin
    if SameText(DatosJSON.GetValue<string>('posicion_imagen', 'izquierda'), 'arriba') then
      HeroImageXML := '            <image placement="hero" src="$ImagenHero"/>' + #13#10
    else
      HeroImageXML := '            <image placement="appLogoOverride" src="$ImagenHero"/>' + #13#10;
  end;

  InlineImageXML := '';
  if FileExists(DatosJSON.GetValue<string>('imagen_inline', '')) then
    InlineImageXML := '            <image src="$ImagenInline"/>' + #13#10;

  PieXML := '';
  if DatosJSON.GetValue<string>('pie_notificacion', '') <> '' then
    PieXML := '            <text placement="attribution">$PieNotificacion</text>' + #13#10;

  LineasCuerpo := TStringList.Create;
  try
    LineasCuerpo.Text := Cuerpo;
    BodyTextXML := '';
    for I := 0 to LineasCuerpo.Count - 1 do
      BodyTextXML := BodyTextXML + '            <text>$Cuerpo[' + IntToStr(I) + ']</text>' + #13#10;
  finally
    LineasCuerpo.Free;
  end;

  AccionPrincipalXML := '';
  if DatosJSON.GetValue<string>('accion_principal', '') <> '' then
    AccionPrincipalXML := '        <action content="Abrir" arguments="$AccionPrincipal" activationType="protocol"/>' + #13#10;

  BotonCerrarXML := '';
  if DatosJSON.GetValue<Boolean>('mostrar_boton_cerrar', False) then
    BotonCerrarXML := '        <action content="Cerrar" arguments="dismiss" activationType="system"/>' + #13#10;

  // --- CONSTRUCCIÓN DEL XML COMPLETO ---
  ToastTemplateXML :=
    '<toast' + DurationAttribute + LaunchAttribute + '>' + #13#10 +
    '    <visual>' + #13#10 +
    '        <binding template="ToastGeneric">' + #13#10 +
                 HeroImageXML +
    '            <text>$Titulo</text>' + #13#10 +
                 BodyTextXML +
                 InlineImageXML +
                 PieXML +
    '        </binding>' + #13#10 +
    '    </visual>';

  if (AccionPrincipalXML <> '') or (BotonCerrarXML <> '') then
  begin
    ToastTemplateXML := ToastTemplateXML + #13#10 +
      '    <actions>' + #13#10 +
           AccionPrincipalXML +
           BotonCerrarXML +
      '    </actions>';
  end;
  ToastTemplateXML := ToastTemplateXML + #13#10 + '</toast>';

  // --- CONSTRUCCIÓN DEL SCRIPT DE POWERSHELL ---
  // <<< CORRECCIÓN: Se construye un array de PowerShell válido >>>
  LineasCuerpo := TStringList.Create;
  LineasEscapadas := TStringList.Create;
  try
    LineasCuerpo.Text := Cuerpo;
    for I := 0 to LineasCuerpo.Count - 1 do
      LineasEscapadas.Add('''' + LineasCuerpo[I].Replace('''', '''''') + '''');
    CuerpoPowerShellArray := '$Cuerpo = @(' + LineasEscapadas.CommaText + ');' + #13#10;
  finally
    LineasCuerpo.Free;
    LineasEscapadas.Free;
  end;

  ScriptPS := '$Titulo = ''' + Titulo.Replace('''', '''''') + ''';' + #13#10 +
    CuerpoPowerShellArray + // Se inserta la declaración del array
    '$ImagenHero = ''' + TPath.GetFullPath(DatosJSON.GetValue<string>('imagen', '')).Replace('''', '''''') + ''';' + #13#10 +
    '$ImagenInline = ''' + TPath.GetFullPath(DatosJSON.GetValue<string>('imagen_inline', '')).Replace('''', '''''') + ''';' + #13#10 +
    '$PieNotificacion = ''' + DatosJSON.GetValue<string>('pie_notificacion', '').Replace('''', '''''') + ''';' + #13#10 +
    '$AccionPrincipal = ''' + DatosJSON.GetValue<string>('accion_principal', '').Replace('''', '''''') + ''';' + #13#10 +
    '$AppId = ''' + APP_ID + ''';' + #13#10 +
    '$ToastTemplate = @"' + #13#10 + ToastTemplateXML + #13#10 + '"@' + #13#10 +
    '[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null;' + #13#10 +
    '[Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime] | Out-Null;' + #13#10 +
    '$ToastXml = New-Object Windows.Data.Xml.Dom.XmlDocument;' + #13#10 +
    '$ToastXml.LoadXml($ToastTemplate);' + #13#10 +
    '$Toast = [Windows.UI.Notifications.ToastNotification]::new($ToastXml);' + #13#10 +
    '[Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier($AppId).Show($Toast);';

  EjecutarComandoPowershell(ScriptPS);
end;

procedure TformNotificacionesWindows.EjecutarComandoPowershell(const Script: string);
var
  ComandoBase64, ComandoCompleto: string;
  SI: TStartupInfo;
  PI: TProcessInformation;
begin
  ComandoBase64 := TNetEncoding.Base64.EncodeBytesToString(TEncoding.Unicode.GetBytes(Script));
  ComandoCompleto := 'powershell.exe -NoProfile -ExecutionPolicy Bypass -EncodedCommand ' + ComandoBase64;
  EscribirLog('Ejecutando PowerShell para mostrar notificación...');
  ZeroMemory(@SI, SizeOf(SI));
  SI.cb := SizeOf(SI);
  SI.dwFlags := STARTF_USESHOWWINDOW;
  SI.wShowWindow := SW_HIDE;
  ZeroMemory(@PI, SizeOf(PI));
  if not CreateProcess(nil, PChar(ComandoCompleto), nil, nil, False, CREATE_NO_WINDOW, nil, nil, SI, PI) then
  begin
    EscribirLog('Error al ejecutar PowerShell: ' + SysErrorMessage(GetLastError), True);
    Exit;
  end;
  try
    WaitForSingleObject(PI.hProcess, 5000);
  finally
    CloseHandle(PI.hProcess);
    CloseHandle(PI.hThread);
  end;
end;

function TformNotificacionesWindows.HaSidoMostradaRecientemente(const ATitulo, ACuerpo: string): Boolean;
var
  Historial: TJSONArray;
  Item: TJSONValue;
  FechaNotificacion: TDateTime;
  FS: TFormatSettings;
begin
  Result := False;
  if not FileExists(FRutaArchivoHistorial) then Exit;
  FS := TFormatSettings.Create;
  FS.ShortDateFormat := 'yyyy-mm-dd';
  FS.DateSeparator := '-';
  FS.TimeSeparator := ':';
  Historial := nil;
  try
    Historial := TJSONObject.ParseJSONValue(TFile.ReadAllText(FRutaArchivoHistorial)) as TJSONArray;
    if not Assigned(Historial) then Exit;
    for Item in Historial do
    begin
      if (Item is TJSONObject) and
         SameText((Item as TJSONObject).GetValue<string>('titulo', ''), ATitulo) and
         SameText((Item as TJSONObject).GetValue<string>('cuerpo', ''), ACuerpo) then
      begin
        if TryStrToDateTime((Item as TJSONObject).GetValue<string>('fecha', ''), FechaNotificacion, FS) then
        begin
          if MinutesBetween(Now, FechaNotificacion) <= MINUTOS_LIMITE_DUPLICADOS then
          begin
            Result := True;
            Exit;
          end;
        end;
      end;
    end;
  finally
    if Assigned(Historial) then
      Historial.Free;
  end;
end;

procedure TformNotificacionesWindows.RegistrarNotificacionEnHistorial(const ATitulo, ACuerpo: string);
var
  Historial: TJSONArray;
  NuevaNotificacion: TJSONObject;
begin
  Historial := nil;
  try
    if FileExists(FRutaArchivoHistorial) then
      Historial := TJSONObject.ParseJSONValue(TFile.ReadAllText(FRutaArchivoHistorial)) as TJSONArray;
    if not Assigned(Historial) then
      Historial := TJSONArray.Create;
    NuevaNotificacion := TJSONObject.Create;
    NuevaNotificacion.AddPair('titulo', ATitulo);
    NuevaNotificacion.AddPair('cuerpo', ACuerpo);
    NuevaNotificacion.AddPair('fecha', FormatDateTime('yyyy-mm-dd hh:nn:ss', Now));
    Historial.AddElement(NuevaNotificacion);
    TFile.WriteAllText(FRutaArchivoHistorial, Historial.ToString);
  finally
    if Assigned(Historial) then
      Historial.Free;
  end;
end;

end.
